/*
 * mfcc_adaboost.c
 *
 *  Created on: Feb 24, 2016
 *      Author: puff
 */


#include<stdio.h>
#include<string.h>
#include<math.h>
//#include <malloc.h>
#include <stdlib.h>
#include"mfcc_adaboost.h"
//#define GetMelnum(idx)       (Mel_num[idx])

static const float ham_suffix_data[] = {
		0.080000,
		0.080140,
		0.080558,
		0.081256,
		0.082232,
		0.083487,
		0.085018,
		0.086825,
		0.088908,
		0.091264,
		0.093893,
		0.096793,
		0.099962,
		0.103398,
		0.107099,
		0.111063,
		0.115287,
		0.119769,
		0.124506,
		0.129496,
		0.134734,
		0.140219,
		0.145946,
		0.151913,
		0.158115,
		0.164549,
		0.171211,
		0.178097,
		0.185203,
		0.192524,
		0.200056,
		0.207794,
		0.215734,
		0.223871,
		0.232200,
		0.240716,
		0.249413,
		0.258287,
		0.267332,
		0.276542,
		0.285912,
		0.295437,
		0.305110,
		0.314925,
		0.324878,
		0.334960,
		0.345168,
		0.355493,
		0.365931,
		0.376474,
		0.387117,
		0.397852,
		0.408674,
		0.419575,
		0.430550,
		0.441591,
		0.452691,
		0.463845,
		0.475045,
		0.486285,
		0.497557,
		0.508854,
		0.520171,
		0.531500,
		0.542834,
		0.554166,
		0.565489,
		0.576797,
		0.588083,
		0.599340,
		0.610560,
		0.621738,
		0.632866,
		0.643938,
		0.654946,
		0.665885,
		0.676747,
		0.687527,
		0.698216,
		0.708810,
		0.719301,
		0.729684,
		0.739951,
		0.750097,
		0.760115,
		0.770000,
		0.779745,
		0.789344,
		0.798793,
		0.808084,
		0.817212,
		0.826172,
		0.834958,
		0.843565,
		0.851988,
		0.860222,
		0.868261,
		0.876100,
		0.883736,
		0.891163,
		0.898377,
		0.905373,
		0.912148,
		0.918696,
		0.925015,
		0.931100,
		0.936947,
		0.942554,
		0.947916,
		0.953030,
		0.957894,
		0.962504,
		0.966857,
		0.970952,
		0.974785,
		0.978353,
		0.981656,
		0.984690,
		0.987455,
		0.989948,
		0.992168,
		0.994113,
		0.995782,
		0.997175,
		0.998290,
		0.999128,
		0.999686,
		0.999965,
		0.999965,
		0.999686,
		0.999128,
		0.998290,
		0.997175,
		0.995782,
		0.994113,
		0.992168,
		0.989948,
		0.987455,
		0.984690,
		0.981656,
		0.978353,
		0.974785,
		0.970952,
		0.966857,
		0.962504,
		0.957894,
		0.953030,
		0.947916,
		0.942554,
		0.936947,
		0.931100,
		0.925015,
		0.918696,
		0.912148,
		0.905373,
		0.898377,
		0.891163,
		0.883736,
		0.876100,
		0.868261,
		0.860222,
		0.851988,
		0.843565,
		0.834958,
		0.826172,
		0.817212,
		0.808084,
		0.798793,
		0.789345,
		0.779745,
		0.770000,
		0.760115,
		0.750097,
		0.739951,
		0.729684,
		0.719302,
		0.708810,
		0.698217,
		0.687527,
		0.676747,
		0.665885,
		0.654946,
		0.643938,
		0.632866,
		0.621738,
		0.610560,
		0.599340,
		0.588083,
		0.576797,
		0.565489,
		0.554166,
		0.542834,
		0.531500,
		0.520171,
		0.508854,
		0.497557,
		0.486285,
		0.475045,
		0.463845,
		0.452692,
		0.441591,
		0.430550,
		0.419575,
		0.408674,
		0.397852,
		0.387117,
		0.376474,
		0.365931,
		0.355493,
		0.345168,
		0.334960,
		0.324878,
		0.314925,
		0.305110,
		0.295437,
		0.285912,
		0.276542,
		0.267331,
		0.258287,
		0.249413,
		0.240716,
		0.232200,
		0.223871,
		0.215734,
		0.207794,
		0.200056,
		0.192524,
		0.185203,
		0.178097,
		0.171211,
		0.164549,
		0.158115,
		0.151913,
		0.145947,
		0.140219,
		0.134734,
		0.129496,
		0.124506,
		0.119769,
		0.115287,
		0.111063,
		0.107099,
		0.103398,
		0.099962,
		0.096793,
		0.093893,
		0.091265,
		0.088908,
		0.086825,
		0.085018,
		0.083487,
		0.082232,
		0.081256,
		0.080558,
		0.080140,
		0.080000,
};

static const float FBank2MFCC_suffix_data[12][26] = {
		{0.998176,0.983620,0.954721,0.911900,0.855781,0.787183,0.707107,0.616719,0.517338,0.410413,0.297503,0.180255,0.060379,-0.060378,-0.180255,-0.297503,-0.410413,-0.517338,-0.616719,-0.707107,-0.787183,-0.855781,-0.911900,-0.954721,-0.983620,-0.998176},
		{0.992709,0.935016,0.822984,0.663123,0.464723,0.239316,0.000000,-0.239316,-0.464723,-0.663123,-0.822984,-0.935016,-0.992709,-0.992709,-0.935016,-0.822984,-0.663123,-0.464723,-0.239316,-0.000000,0.239316,0.464723,0.663123,0.822984,0.935016,0.992709},
		{0.983620,0.855781,0.616719,0.297503,-0.060378,-0.410413,-0.707107,-0.911900,-0.998176,-0.954721,-0.787183,-0.517338,-0.180255,0.180255,0.517338,0.787183,0.954721,0.998176,0.911900,0.707107,0.410413,0.060379,-0.297503,-0.616719,-0.855781,-0.983620},
		{0.970942,0.748511,0.354605,-0.120537,-0.568065,-0.885456,-1.000000,-0.885456,-0.568065,-0.120537,0.354605,0.748511,0.970942,0.970942,0.748511,0.354605,-0.120536,-0.568065,-0.885456,-1.000000,-0.885456,-0.568065,-0.120537,0.354605,0.748511,0.970942},
		{0.954721,0.616719,0.060378,-0.517338,-0.911900,-0.983620,-0.707107,-0.180255,0.410413,0.855781,0.998176,0.787183,0.297503,-0.297503,-0.787184,-0.998176,-0.855781,-0.410413,0.180255,0.707107,0.983620,0.911900,0.517338,-0.060379,-0.616719,-0.954721},
		{0.935016,0.464723,-0.239316,-0.822984,-0.992709,-0.663123,-0.000000,0.663123,0.992709,0.822984,0.239316,-0.464723,-0.935016,-0.935016,-0.464723,0.239316,0.822984,0.992709,0.663123,0.000000,-0.663123,-0.992709,-0.822984,-0.239316,0.464723,0.935016},
		{0.911900,0.297503,-0.517338,-0.983620,-0.787184,-0.060379,0.707107,0.998176,0.616719,-0.180255,-0.855781,-0.954721,-0.410413,0.410413,0.954721,0.855781,0.180255,-0.616719,-0.998176,-0.707107,0.060378,0.787183,0.983620,0.517338,-0.297503,-0.911900},
		{0.885456,0.120537,-0.748511,-0.970942,-0.354605,0.568065,1.000000,0.568065,-0.354605,-0.970942,-0.748511,0.120536,0.885456,0.885456,0.120537,-0.748510,-0.970942,-0.354605,0.568064,1.000000,0.568065,-0.354604,-0.970942,-0.748511,0.120536,0.885456},
		{0.855781,-0.060378,-0.911900,-0.787184,0.180255,0.954721,0.707107,-0.297503,-0.983620,-0.616719,0.410412,0.998176,0.517338,-0.517337,-0.998176,-0.410413,0.616718,0.983620,0.297504,-0.707106,-0.954721,-0.180256,0.787183,0.911900,0.060379,-0.855781},
		{0.822984,-0.239316,-0.992709,-0.464723,0.663123,0.935016,-0.000000,-0.935016,-0.663123,0.464723,0.992709,0.239315,-0.822984,-0.822984,0.239316,0.992709,0.464723,-0.663123,-0.935016,0.000000,0.935016,0.663122,-0.464723,-0.992709,-0.239315,0.822984},
		{0.787184,-0.410413,-0.983620,-0.060379,0.954721,0.517338,-0.707107,-0.855781,0.297503,0.998176,0.180256,-0.911900,-0.616719,0.616718,0.911900,-0.180254,-0.998176,-0.297504,0.855781,0.707108,-0.517337,-0.954721,0.060377,0.983620,0.410414,-0.787183},
		{0.748511,-0.568065,-0.885456,0.354605,0.970942,-0.120537,-1.000000,-0.120537,0.970942,0.354605,-0.885456,-0.568065,0.748511,0.748511,-0.568065,-0.885456,0.354605,0.970942,-0.120537,-1.000000,-0.120537,0.970942,0.354605,-0.885456,-0.568065,0.748511}
};

static const float lochan_num[]=
{
		-1.000000,
		0.000000,
		0.000000,
		0.000000,
		1.000000,
		1.000000,
		1.000000,
		1.000000,
		2.000000,
		2.000000,
		2.000000,
		2.000000,
		3.000000,
		3.000000,
		3.000000,
		3.000000,
		3.000000,
		4.000000,
		4.000000,
		4.000000,
		4.000000,
		4.000000,
		4.000000,
		5.000000,
		5.000000,
		5.000000,
		5.000000,
		5.000000,
		5.000000,
		6.000000,
		6.000000,
		6.000000,
		6.000000,
		6.000000,
		6.000000,
		7.000000,
		7.000000,
		7.000000,
		7.000000,
		7.000000,
		7.000000,
		7.000000,
		7.000000,
		8.000000,
		8.000000,
		8.000000,
		8.000000,
		8.000000,
		8.000000,
		8.000000,
		8.000000,
		9.000000,
		9.000000,
		9.000000,
		9.000000,
		9.000000,
		9.000000,
		9.000000,
		9.000000,
		9.000000,
		10.000000,
		10.000000,
		10.000000,
		10.000000,
		10.000000,
		10.000000,
		10.000000,
		10.000000,
		10.000000,
		10.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		11.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		12.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		13.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		14.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		15.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		16.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		17.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		18.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		19.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000,
		20.000000
};
static const float lowt_num[]=
{
		0.000000,
		0.709533,
		0.427616,
		0.153764,
		0.887524,
		0.628487,
		0.376272,
		0.130531,
		0.890938,
		0.657193,
		0.429019,
		0.206154,
		0.988359,
		0.775406,
		0.567088,
		0.363203,
		0.163570,
		0.968014,
		0.776370,
		0.588487,
		0.404219,
		0.223431,
		0.045992,
		0.871782,
		0.700684,
		0.532589,
		0.367393,
		0.205000,
		0.045315,
		0.888248,
		0.733717,
		0.581640,
		0.431939,
		0.284543,
		0.139382,
		0.996388,
		0.855497,
		0.716651,
		0.579786,
		0.444853,
		0.311793,
		0.180557,
		0.051096,
		0.923360,
		0.797307,
		0.672892,
		0.550071,
		0.428806,
		0.309058,
		0.190789,
		0.073962,
		0.958544,
		0.844499,
		0.731798,
		0.620406,
		0.510296,
		0.401439,
		0.293804,
		0.187365,
		0.082097,
		0.977973,
		0.874969,
		0.773062,
		0.672226,
		0.572443,
		0.473688,
		0.375941,
		0.279182,
		0.183391,
		0.088548,
		0.994635,
		0.901635,
		0.809529,
		0.718301,
		0.627933,
		0.538410,
		0.449716,
		0.361837,
		0.274756,
		0.188460,
		0.102934,
		0.018167,
		0.934142,
		0.850849,
		0.768274,
		0.686405,
		0.605230,
		0.524736,
		0.444915,
		0.365752,
		0.287239,
		0.209365,
		0.132118,
		0.055490,
		0.979470,
		0.904048,
		0.829217,
		0.754964,
		0.681284,
		0.608166,
		0.535603,
		0.463583,
		0.392104,
		0.321152,
		0.250722,
		0.180809,
		0.111400,
		0.042490,
		0.974074,
		0.906144,
		0.838690,
		0.771710,
		0.705195,
		0.639137,
		0.573534,
		0.508377,
		0.443659,
		0.379375,
		0.315521,
		0.252090,
		0.189076,
		0.126475,
		0.064278,
		0.002484,
		0.941086,
		0.880080,
		0.819458,
		0.759219,
		0.699357,
		0.639865,
		0.580742,
		0.521981,
		0.463580,
		0.405530,
		0.347832,
		0.290478,
		0.233467,
		0.176793,
		0.120452,
		0.064440,
		0.008755,
		0.953391,
		0.898345,
		0.843615,
		0.789195,
		0.735084,
		0.681275,
		0.627767,
		0.574557,
		0.521641,
		0.469015,
		0.416677,
		0.364624,
		0.312853,
		0.261359,
		0.210140,
		0.159195,
		0.108519,
		0.058110,
		0.007965,
		0.958080,
		0.908455,
		0.859086,
		0.809968,
		0.761103,
		0.712485,
		0.664112,
		0.615984,
		0.568096,
		0.520445,
		0.473031,
		0.425850,
		0.378900,
		0.332181,
		0.285687,
		0.239420,
		0.193374,
		0.147546,
		0.101939,
		0.056549,
		0.011370,
		0.966406,
		0.921650,
		0.877102,
		0.832762,
		0.788627,
		0.744691,
		0.700959,
		0.657423,
		0.614087,
		0.570946,
		0.527995,
		0.485240,
		0.442673,
		0.400293,
		0.358102,
		0.316096,
		0.274272,
		0.232632,
		0.191169,
		0.149889,
		0.108783,
		0.067853,
		0.027099,
		0.986516,
		0.946105,
		0.905864,
		0.865791,
		0.825883,
		0.786144,
		0.746567,
		0.707154,
		0.667902,
		0.628811,
		0.589879,
		0.551104,
		0.512485,
		0.474022,
		0.435712,
		0.397554,
		0.359549,
		0.321694,
		0.283988,
		0.246429,
		0.209018,
		0.171752,
		0.134631,
		0.097653,
		0.060816,
		0.024122,
		0.987568,
		0.951152,
		0.914873,
		0.878733,
		0.842728,
		0.806858,
		0.771121,
		0.735518,
		0.700047,
		0.664706,
		0.629495,
		0.594413,
		0.559460,
		0.524634,
		0.489934,
		0.455358,
		0.420907,
		0.386580,
		0.352376,
		0.318294,
		0.284330,
		0.250489,
		0.216766,
		0.183161,
		0.149677,
		0.116304
};

#define GetHamValueSuffix(idx)       (ham_suffix_data[idx])
#define Getlochannum(idx)            (lochan_num[idx])
#define Getlowtnum(idx)              (lowt_num[idx])

 float fbank[27];
 float c[13];
 float En;
 float offset=-256;
 float mfcc_feature[13];

 int label=0;

 int frame_index=0;
 int frame_result[500];
 static void GenCepWin (float *cw,int cepLiftering, int count);
 //计算并返回score,输入mfcc_feature[39],和model_var[weakclassifier_var]
 static double evaluate(float *mfcc_feature,model* model_var);
 //predict,输入mfcc_feature和model_file,返回1--dog,0--noise
 static int predict(float* mfcc_feature,model* model_var);
 static void PreEmphasise (float *s, float k);
 static void Ham (float *s,int frameSize);
 static void initfft(float* data,float* fftbuf);
 static void Realft (float *s);
 static void FFT(float *s, int invert);
 //static float Mel(int k,float fres);
 static void Wave2FBank(float *fftbuf);
 static void FBank2MFCC(int n);
 static void CptEn(float *s);
 static void WeightCepstrum (int start, int count, int cepLiftering);


void GetMfcc(short *buffer,int len,model *model)
{
    if (len !=ipframesize)
        printf("the length of wav data should be 256");
    else
    {
        float* data=(float*)malloc((ipframesize+1)*sizeof(float));
        float* fftbuf=(float*)malloc((fftcoef)*sizeof(float));
        memset(fftbuf, 0, (fftcoef)*sizeof(float));
        int i=0;
        for(i=0;i<ipframesize;i++) data[i+1]=buffer[i];
        float PREEMCOEF=0.97;
        //long long time_pre = GetNTime();
        PreEmphasise (data, PREEMCOEF);
        //long long time_Ham = GetNTime();

	    //printf( "time_pre time is %qi\n",time_Ham-time_pre );
        Ham (data, ipframesize);
       // long long time_CptEn = GetNTime();

        //printf( "time_Ham time is %qi\n",time_CptEn-time_Ham );
        CptEn(data);

        //long long time_initfft = GetNTime();

        //printf( "time_CptEn time is %qi\n",time_initfft-time_CptEn );
        initfft(data,fftbuf);
        free(data);
       // long long time_Realft= GetNTime();
        //printf( "time_initfft time is %qi\n",time_Realft-time_initfft );
        Realft (fftbuf);
        //long long time_Wave2FBank = GetNTime();
        //printf( "time_Realft time is %qi\n",time_Wave2FBank-time_Realft );
        Wave2FBank(fftbuf);
       // long long time_FBank2MFCC = GetNTime();
        //printf( "time_Wave2FBank  time is %qi\n",time_FBank2MFCC-time_Wave2FBank );
        FBank2MFCC(12);
        ///long long time_WeightCepstrum = GetNTime();
        //printf( "time_FBank2MFCC time is %qi\n",time_WeightCepstrum-time_FBank2MFCC );
        WeightCepstrum (1, 12, 22);
        //long long time_predict = GetNTime();
        //printf( "time_WeightCepstrum time is %qi\n",time_predict-time_WeightCepstrum);
        free(fftbuf);

         //predict the result for every frame
         int j=1;
         mfcc_feature[0]=En;
         for (j=1;j<=12;j++)
         {
             mfcc_feature[j]=c[j];
         }
    }
   // long long time_GetFrame_Result = GetNTime();
    GetFrame_Result(mfcc_feature,model);
    //long long time_whileend = GetNTime();
}

void GetFrame_Result(float* mfcc_feature,model* model_var)
{
	 frame_index++;//count num
	 frame_result[frame_index]=predict(mfcc_feature,model_var);
		//printf("mfcc_feature[1] is %f\n",mfcc_feature[1]);
		// printf("frame_result[frame_index] is %d %d\n",frame_index,frame_result[frame_index]);
	// printf("frame_index is %d\n",frame_index);
}
int GetFinal_Result()
{
	 label=0;
	 int index_i=0;
	 for(index_i=0;index_i<frame_index-windowsize;index_i++)
	 {
		 int sum=0,index_j=0;
		 float sum_thresold=rightrate*windowsize;
		 for(index_j=index_i;index_j<index_i+windowsize;index_j++) sum=sum+frame_result[index_j];
		 //printf("sum is %d\n",sum);printf("sum_thresold is %f\n",sum_thresold);
		 if (sum >sum_thresold) {label=1;break;}
	 }
	 return label;
}

void PreEmphasise (float *s, float k)
{
   int i;
   float preE;

   preE = k;
   for (i=ipframesize;i>=2;i--)
      s[i] -= s[i-1]*preE;
   s[1] *= 1.0-preE;
}




/* EXPORT->Ham: Apply Hamming Window to Speech frame s */
void Ham (float *s,int frameSize)
{
	int i;
    for (i=1;i<=frameSize;i++) s[i] =s[i]*GetHamValueSuffix(i-1) ;
}


/* EXPORT-> FFT: apply fft/invfft to complex s */
void FFT(float *s, int invert)
{
   int ii,jj,n,nn,limit,m,j,inc,i;
   float wx,wr,wpr,wpi,wi,theta;
   float xre,xri,x;
   n=fftcoef;
   nn=n / 2; j = 1;
   for (ii=1;ii<=nn;ii++) {
      i = 2 * ii - 1;
      if (j>i) {
         xre = s[j]; xri = s[j + 1];
         s[j] = s[i];  s[j + 1] = s[i + 1];
         s[i] = xre; s[i + 1] = xri;
      }
      m = n / 2;
      while (m >= 2  && j > m) {
         j -= m; m /= 2;
      }
      j += m;
   };
   limit = 2;
  // while (limit < n)
   float wpr_num[8]={-2.000000,-1.000000,-0.292893,-0.076120,-0.019215,-0.004815,-0.001205,-0.000301};
   float wpi_num[8]={0.000000,1.000000,0.707107,0.382683,0.195090,0.098017,0.049068,0.024541};
   int index=0;
   for(limit=2;limit<n;limit=limit*2)
   {
      inc = 2 * limit;
      //theta = TPI / limit;
      //x = sin(0.5 * theta);////////////////////
      //wpr = -2.0 * x * x; wpi = sin(theta);////////
      wpr=wpr_num[index];
      wpi=wpi_num[index];
      wr = 1.0; wi = 0.0;
      for (ii=1; ii<=limit/2; ii++) {
         m = 2 * ii - 1;
         for (jj = 0; jj<=(n - m) / inc;jj++) {
            i = m + jj * inc;
            j = i + limit;
            xre = wr * s[j] - wi * s[j + 1];
            xri = wr * s[j + 1] + wi * s[j];
            s[j] = s[i] - xre; s[j + 1] = s[i + 1] - xri;
            s[i] = s[i] + xre; s[i + 1] = s[i + 1] + xri;
         }
         wx = wr;
         wr = wr * wpr - wi * wpi + wr;/////////
         wi = wi * wpr + wx * wpi + wi;/////////
      }
      index++;
   }


   if (invert)
      for (i = 1;i<=n;i++)
         s[i] = s[i] / nn;

}

/* EXPORT-> Realft: apply fft to real s */
void Realft (float *s)
{
   int n, n2, i, i1, i2, i3, i4;
   float xr1, xi1, xr2, xi2, wrs, wis;
   float yr, yi, yr2, yi2, yr0;

   n=fftcoef/ 2; n2 = n/2;
   //theta = 0.012272;
   FFT(s,0);
   //x =0.006136;// sin(0.5 * theta);//////////
   yr2 =-0.000075;// -2.0 * x * x;///////////////////////
   yi2 = 0.012272;//sin(theta);
   yr = 0.999925;//1.0 + yr2;
   yi = yi2;/////////////////
   for (i=2; i<=n2; i++) {
      i1 = i + i - 1;      i2 = i1 + 1;
      i3 = n + n + 3 - i2; i4 = i3 + 1;
      wrs = yr; wis = yi;
      xr1 = (s[i1] + s[i3])/2.0; xi1 = (s[i2] - s[i4])/2.0;
      xr2 = (s[i2] + s[i4])/2.0; xi2 = (s[i3] - s[i1])/2.0;
      s[i1] = xr1 + wrs * xr2 - wis * xi2;
      s[i2] = xi1 + wrs * xi2 + wis * xr2;
      s[i3] = xr1 - wrs * xr2 + wis * xi2;
      s[i4] = -xi1 + wrs * xi2 + wis * xr2;
      yr0 = yr;
      yr = yr * yr2 - yi  * yi2 + yr;
      yi = yi * yr2 + yr0 * yi2 + yi;
   }
   xr1 = s[1];
   s[1] = xr1 + s[2];
   s[2] = 0.0;
}





void initfft(float* data,float* fftbuf)
{
  int k;
  for (k=1; k<=ipframesize; k++)
	 fftbuf[k] = data[k];    /* copy to workspace */
   //for (k=ipframesize+1; k<=fftcoef; k++)///////去掉
      //fftbuf[k] = 0.0;   /* pad with zeroes */

}

void Wave2FBank(float *fftbuf)
{
   //wave2bank
   const float melfloor = 1.0;
   int k,bin;
   float t1,t2;   /* real and imag parts */
   float ek;      /* energy of k'th fft channel */

   for (k = 2; k <= ipframesize-1; k++)
   {             /* fill bins */

        t1 = fftbuf[2*k-1]; t2 = fftbuf[2*k];

        ek = sqrt(t1*t1 + t2*t2);
        bin =  Getlochannum(k-1);
        t1 =  Getlowtnum(k-1) *ek;
        if (bin>0) fbank[bin] += t1;
        if (bin<26) fbank[bin+1] += ek - t1;
    }

      /* Take logs */
     // if (info.takeLogs)
   for (bin=1; bin<=26; bin++)
   {
        t1 = fbank[bin];
        if (t1<melfloor) t1 = melfloor;
        fbank[bin] = log(t1);
   }
}

#define GetFBank2MFCCValue(idx_j,idx_k)       (FBank2MFCC_suffix_data[idx_j][idx_k])

/* EXPORT->FBank2MFCC: compute first n cepstral coeff */
void FBank2MFCC(int n)
{
   int j,k,numChan;
   float mfnorm;

   numChan =26;
   mfnorm =0.277350; //sqrt(2.0/(float)numChan);///////////////////
   //pi_factor=0.120830; //= PI/(float)numChan;////////////////////////
   for (j=1; j<=n; j++)  {
      c[j] = 0.0;// x = (float)j * pi_factor;
      for (k=1; k<=numChan; k++)
         c[j] += fbank[k] * GetFBank2MFCCValue(j-1,k-1) ;
      c[j] *= mfnorm;
   }
}







/* ¼ÆËãÃ¿Ö¡µÄÄÜÁ¿ */
void CptEn(float *s)
{

     En = 0.0;
     int k=1;
    for (k=1; k<=ipframesize; k++)
      En += (s[k]*s[k]);
	En=log(En);

}


void WeightCepstrum (int start, int count, int cepLiftering)
{
   int i,j;
   float cepWin[13];
   //if (cepWinL != cepLiftering || count > cepWinSize)
   GenCepWin(cepWin, cepLiftering,count);
   j = start;
   for (i=1;i<=count;i++)
      c[j++] *= cepWin[i];
}




/* GenCepWin: generate a new cep liftering vector */
static void GenCepWin (float *cw,int cepLiftering, int count)
{
   int i;
   float a, Lby2;

  // if (cepWin==NULL || VectorSize(cepWin) < count)
   //   cepWin = CreateVector(&sigpHeap,count);
   a = PI/cepLiftering;
   Lby2 = cepLiftering/2.0;
   for (i=1;i<=count;i++)
      cw[i] = 1.0 + Lby2*sin(i * a);

}

int predict(float* mfcc_feature,model* model_var)
{
	float score = evaluate(mfcc_feature,model_var);
	int frame_result=0;
	if (score>0)
		frame_result=1;
	else frame_result=0;
	return frame_result;
}

double evaluate(float *mfcc_feature,model* model_var)
{
	int i=0;
	float score=0;
    for (i = 0; i < weakclassifier_num; ++i)//waek_classfier_model_index
    {
    	int feature_index=model_var[i].featureIndex;

    	if ( mfcc_feature[feature_index] > model_var[i].threshold )
    		score += model_var[i].outputLarger;
    	else score += model_var[i].outputSmaller;
    }
    return score;
}


